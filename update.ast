#!/usr/bin/env asteria
// No Copyright
//
// Permission to use, copy, modify, and/or distribute this software for
// any purpose with or without fee is hereby granted.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
// WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE
// FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
// DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
// OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

const SDK_LIB_ROOT = 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0';

const DEF_COPYRIGHT = [
  'This file is automatically generated from the corresponding import library',
  'from Microsoft Windows SDK. Permission to use, copy, modify, and/or',
  'distribute this software for any purpose with or without fee is hereby',
  'granted. No copyright is reserved.',
  '',
  'In order to generate an import library with GNU DLLTOOL, the `--kill-at`',
  'option is required.',
  '',
  'THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL',
  'WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES',
  'OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE',
  'FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY',
  'DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN',
  'AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT',
  'OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.',
];

const IGNORED_LIBS = [
  'uuid.lib',
  'thunk32.lib',
  'libucrt.lib',
  'libucrtd.lib',
];

const PRIVATE_FUNCTIONS = [
  'DllGetClassObject',
  'DllGetClassObjectWOW',
  'DllCanUnloadNow',
  'DllGetClassFactoryFromClassString',
  'DllGetDocumentation',
  'DllInitialize',
  'DllUnload',
  'DllInstall',
  'DllRegisterServer',
  'DllRegisterServerEx',
  'DllRegisterServerExA',
  'DllRegisterServerExW',
  'DllRegisterProxy',
  'DllRegisterWindowClasses',
  'DllUnregisterServer',
  'DllUnregisterServerWeReallyMeanIt',  // ?? what does this damn thing do?
  'DllUnregisterProxy',
  '_DllEntryPoint',
  '_DllMainCRTStartup',   // MSVC entry point
  '_DllMainCRTStartupForGS',
  '_DllMainCRTStartupForGS2',
  'DllMain',
  'DllMainCRTStartup',  // MinGW entry point
  'DllGetVersion',
  'DllDebugObjectRPCHook',
  'RasCustomDeleteEntryNotify',
  'RasCustomDial',
  'RasCustomDialDlg',
  'RasCustomEntryDlg',
];

const PRIVATE_DATA_PREFIXES = [
  'IID_',
  'LIBID_',
  'CLSID_',
];

/////////////////////////////////////////////////////////////////////////////

// C:\Program Files\.../x64/ActiveDS.Lib(ACTIVEDS.dll):      file format COFF-import-file
const re_object_header = std.string.PCRE(
    '([-_.0-9a-z ():\\/]*\.lib)\((?<name>[-_.0-9a-z]+)\):\s+file format (?<fmt>[-_.0-9a-z]+)\n'
    + '(?<remaining>.*)$',
    [ 'caseless', 'dotall' ]);

// [ 0](sec  0)(fl 0x00)(ty   0)(scl   0) (nx 0) 0x00000000 __imp_ADsBuildEnumerator
const re_symbol = std.string.PCRE(
    '\[ *[0-9]+\]\(sec +[0-9]+\)\(fl +0x[0-9a-f]+\)\(ty +(?<type>[0-9]+)\)\(scl +[0-9]+\)\s+'
    + '\(nx +[0-9]+\)\s+0x[0-9a-f]+\s+(?<sym>[0-9a-z_.$#@!?]+)\n'
    + '(?<remaining>.*)$',
    [ 'caseless', 'dotall' ]);

// collect LIB files.
var um_arch_dll_syms = {};
var um_arch_libs = {};
var nlibs_total = 0;
var nlibs_done = 0;

for(each um, um_props -> std.filesystem.list(SDK_LIB_ROOT)) {
  if!(um_props.is_directory)
    continue;

  for(each arch, arch_props -> std.filesystem.list(SDK_LIB_ROOT / um)) {
    if!(arch_props.is_directory)
      continue;

    for(each lib, lib_props -> std.filesystem.list(SDK_LIB_ROOT / um / arch)) {
      if(lib_props.is_directory
          || !std.string.ends_with(std.string.to_lower(lib), '.lib')
          || (std.array.find(IGNORED_LIBS, std.string.to_lower(lib)) != null))
        continue;

      um_arch_libs[um][arch][$] = SDK_LIB_ROOT / um / arch / lib;
      nlibs_total ++;
    }
  }
}

for(each um, arch_libs -> um_arch_libs) {
  for(each lib_arch, libs -> arch_libs) {
    for(each lib -> libs) {
      nlibs_done ++;
      std.io.putfln("Processing $1/$2: $3", nlibs_done, nlibs_total, lib);

      // dump symbols.
      var lib_data = std.system.pipe('llvm-objdump',
                                     [ '--wide', '--syms', lib ],
                                     [ 'LC_ALL=C' ]);
      if(lib_data == null)
        continue;

      if(std.string.find(lib_data, '__imp_') == null)
        continue;

      lib_data = std.string.replace(lib_data, "\r\n", "\n");
      var lib_size_total = #lib_data;

      // parse object files.
      var obj_m = re_object_header.named_match(lib_data);
      while(obj_m != null) {
        // find next object.
        var m = obj_m;
        lib_data = obj_m.remaining;
        obj_m = re_object_header.named_match(lib_data);

        var dll = std.string.to_lower(m.name);
        if((dll == 'ntdll.dll') && std.string.ends_with(std.string.to_lower(lib), 'ntdllp.lib'))
          dll = 'ntdllp.xxx';

        if(std.string.starts_with(m.fmt, 'COFF-import-file')) {
          // parse short import object.
          var obj_data = std.string.slice(lib_data, 0, #lib_data - #(obj_m.'&'));
          var sym_m = re_symbol.named_match(obj_data);
          while(sym_m != null) {
            // find next symbol.
            m = sym_m;
            obj_data = sym_m.remaining;
            sym_m = re_symbol.named_match(obj_data);

            // demangle it.
            var arch = lib_arch;
            var sym = m.sym;

            if(lib_arch == 'arm64') {
              if(std.string.starts_with(sym, '__imp_aux_')) {
                arch = 'arm64ec';
                sym = std.string.slice(sym, 10);
              }
              else if(std.string.starts_with(sym, '#')) {
                arch = 'arm64ec';
                sym = std.string.slice(sym, 1);
              }
            }

            if(std.string.starts_with(sym, '__imp_'))
              sym = std.string.slice(sym, 6);

            if((arch == 'x86') && std.string.starts_with(sym, '_'))
              sym = std.string.slice(sym, 1);

            if(std.string.starts_with(m.sym, '__imp_')) {
              // `__imp_` or `__imp_aux`
              um_arch_dll_syms[um][arch][dll][sym].imp = true;
            }
            else if(m.type == '0') {
              // `DATA` or `CONSTANT`
              um_arch_dll_syms[um][lib_arch][dll][sym].data = true;
              um_arch_dll_syms[um][arch][dll][sym].data = true;
            }
            else if(m.type == '20') {
              // function; thunk exists
              um_arch_dll_syms[um][arch][dll][sym].thunk = true;
            }
          }
        }

        // TODO: Windows SDK doesn't seem to provide import libraries in the
        // long format. If it does, please let me know.
      }
    }
  }
}

for(each um, arch_dll_syms -> um_arch_dll_syms) {
  for(each arch, dll_syms -> arch_dll_syms) {
    for(each dll, syms -> dll_syms) {
      // sort symbols in alphabetic order.
      var sorted_syms = [];
      for(each sym, props -> syms) {
        if!(props.imp)
          continue;

        var attrs = "";
        for(each priv -> PRIVATE_FUNCTIONS)
          if((sym == priv)
             || ((arch == 'x86') && std.string.starts_with(sym, priv + '@')))
            attrs = " PRIVATE";

        if(attrs == "") {
          if!(props.thunk)
            attrs = " DATA";

          for(each priv -> PRIVATE_DATA_PREFIXES)
            if(std.string.starts_with(sym, priv))
              attrs = " DATA PRIVATE";
        }

        sorted_syms[$] = sym + attrs;
      }

      sorted_syms = std.array.sort(sorted_syms,
          func(x, y) = std.string.to_lower(x) <=> std.string.to_lower(y));

      // compose DEF data.
      var def_data = "";
      for(each line -> DEF_COPYRIGHT)
        if(line == "")
          def_data += ";\n";
        else {
          def_data += "; ";
          def_data += line;
          def_data += "\n";
        }

      def_data += "\n";
      def_data += "LIBRARY \"";

      if(dll == 'ntdllp.xxx')
        def_data += 'ntdll.dll';
      else
        def_data += dll;

      def_data += "\"\n";
      def_data += "EXPORTS\n";
      for(each sym -> sorted_syms)  {
        def_data += "  ";
        def_data += sym;
        def_data += "\n";
      }

      // guess name of DEF file.
      var ext = std.string.pcre_find(dll, '\.[a-z0-9]{1,3}$');
      var def = std.string.replace_slice(dll, ext[0] ?? #dll, '.def');

      std.io.putfln("Writing: $1", um / arch / def);
      std.filesystem.create_directory(um);
      std.filesystem.create_directory(um / arch);
      std.filesystem.write(um / arch / def, def_data);
    }
  }
}
