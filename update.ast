#!/usr/bin/env asteria
// No Copyright
//
// Permission to use, copy, modify, and/or distribute this software for
// any purpose with or without fee is hereby granted.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
// WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE
// FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
// DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
// OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

const SDK_LIB_ROOT = 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0';

const DEF_COPYRIGHT = [
  'This file is automatically generated from the corresponding import library',
  'from Microsoft Windows SDK. Permission to use, copy, modify, and/or',
  'distribute this software for any purpose with or without fee is hereby',
  'granted. No copyright is reserved.',
  '',
  'In order to generate an import library with GNU DLLTOOL, the `--kill-at`',
  'option is required.',
  '',
  'THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL',
  'WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES',
  'OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE',
  'FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY',
  'DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN',
  'AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT',
  'OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.',
];

const PRIVATE_FUNCTIONS = [
  'DllGetClassObject',
  'DllGetClassObjectWOW',
  'DllCanUnloadNow',
  'DllGetClassFactoryFromClassString',
  'DllGetDocumentation',
  'DllInitialize',
  'DllUnload',
  'DllInstall',
  'DllRegisterServer',
  'DllRegisterServerEx',
  'DllRegisterServerExA',
  'DllRegisterServerExW',
  'DllRegisterProxy',
  'DllRegisterWindowClasses',
  'DllUnregisterServer',
  'DllUnregisterServerWeReallyMeanIt',  // ?? what does this damn thing do?
  'DllUnregisterProxy',
  '_DllEntryPoint',
  '_DllMainCRTStartup',   // MSVC entry point
  '_DllMainCRTStartupForGS',
  '_DllMainCRTStartupForGS2',
  'DllMain',
  'DllMainCRTStartup',  // MinGW entry point
  'DllGetVersion',
  'DllDebugObjectRPCHook',
  'RasCustomDeleteEntryNotify',
  'RasCustomDial',
  'RasCustomDialDlg',
  'RasCustomEntryDlg',
];

/////////////////////////////////////////////////////////////////////////////

// C:\Program Files\.../x64/ActiveDS.Lib(ACTIVEDS.dll):      file format COFF-import-file
const re_object_header = std.string.PCRE(
    '([-_.0-9a-z ():\\/]*\.lib)\((?<name>[-_.0-9a-z]+)\):\s+file format (?<fmt>[-_.0-9a-z]+)\n'
    + '(?<remaining>.*)$',
    [ 'caseless', 'dotall' ]);

// [ 0](sec  0)(fl 0x00)(ty   0)(scl   0) (nx 0) 0x00000000 __imp_ADsBuildEnumerator
const re_symbol = std.string.PCRE(
    '\[ *[0-9]+\]\(sec +[0-9]+\)\(fl +0x[0-9a-f]+\)\(ty +(?<type>[0-9]+)\)\(scl +[0-9]+\)\s+'
    + '\(nx +[0-9]+\)\s+0x[0-9a-f]+\s+(?<sym>[0-9a-z_.$#@!?]+)\n'
    + '(?<remaining>.*)$',
    [ 'caseless', 'dotall' ]);

// collect LIB files.
var arch_dll_syms = {};
var arch_libs = {};
var nlibs_total = 0;
var nlibs_done = 0;

for(each um, um_props -> std.filesystem.list(SDK_LIB_ROOT)) {
  if!(um_props.is_directory)
    continue;

  for(each arch, arch_props -> std.filesystem.list(SDK_LIB_ROOT / um)) {
    if!(arch_props.is_directory)
      continue;

    for(each lib, lib_props -> std.filesystem.list(SDK_LIB_ROOT / um / arch)) {
      if(lib_props.is_directory)
        continue;
      else if!(std.string.ends_with(std.string.to_lower(lib), '.lib'))
        continue;

      arch_libs[arch][$] = SDK_LIB_ROOT / um / arch / lib;
      nlibs_total ++;
    }
  }
}

for(each lib_arch, libs -> arch_libs) {
  for(each lib -> libs) {
    nlibs_done ++;
    std.io.putfln("Processing $1/$2: $3", nlibs_done, nlibs_total, lib);

    // dump symbols.
    var lib_data = std.system.pipe('llvm-objdump',
                                   [ '--wide', '--syms', lib ],
                                   [ 'LC_ALL=C' ]);
    if(lib_data == null)
      continue;

    lib_data = std.string.replace(lib_data, "\r\n", "\n");
    var lib_size_total = #lib_data;

    // parse object files.
    var obj_m = re_object_header.named_match(lib_data);
    while(obj_m != null) {
      // find next object.
      var m = obj_m;
      lib_data = obj_m.remaining;
      obj_m = re_object_header.named_match(lib_data);

      var dll, arch, sym;
      if(std.string.starts_with(m.fmt, 'COFF-import-file')) {
        // parse short import object.
        dll = std.string.to_lower(m.name);
        var obj_data = std.string.slice(lib_data, 0, #lib_data - #(obj_m.'&'));
        var sym_m = re_symbol.named_match(obj_data);
        while(sym_m != null) {
          // find next symbol.
          m = sym_m;
          obj_data = sym_m.remaining;
          sym_m = re_symbol.named_match(obj_data);

          // demangle it.
          arch = lib_arch;
          sym = m.sym;

          if(lib_arch == 'arm64') {
            if(std.string.starts_with(sym, '__imp_aux_')) {
              arch = 'arm64ec';
              sym = std.string.slice(sym, 10);
            }
            else if(std.string.starts_with(sym, '#')) {
              arch = 'arm64ec';
              sym = std.string.slice(sym, 1);
            }
          }

          if(std.string.starts_with(sym, '__imp_'))
            sym = std.string.slice(sym, 6);

          if((arch == 'x86') && std.string.starts_with(sym, '_'))
            sym = std.string.slice(sym, 1);

          if(std.string.starts_with(m.sym, '__imp_')) {
            // `__imp_` or `__imp_aux`
            arch_dll_syms[arch][dll][sym].imp = true;
          }
          else if(m.type == '0') {
            // `DATA` or `CONSTANT`
            arch_dll_syms[lib_arch][dll][sym].data = true;
            arch_dll_syms[arch][dll][sym].data = true;
          }
          else if(m.type == '20') {
            // function; thunk exists
            arch_dll_syms[arch][dll][sym].thunk = true;
          }
        }
      }

      // TODO: Windows SDK doesn't seem to provide import libraries in the
      // long format. If it does, please let me know.

      if(sym != null) {
        var rt = (nlibs_done - 1.0 * #lib_data / lib_size_total) / nlibs_total * 100;
        var rt_i = std.numeric.format(__itrunc rt, 10);
        var rt_d = std.string.slice(std.numeric.format(__itrunc(1e9 + rt * 1e4), 10), -4);
        std.io.putfln(" ($1.$2 %) found short import: $3", rt_i, rt_d, m.sym);
      }
    }
  }
}

for(each arch, dll_syms -> arch_dll_syms) {
  std.filesystem.create_directory(arch);

  for(each dll, syms -> dll_syms) {
    // sort symbols in alphabetic order.
    var sorted_syms = [];
    for(each sym, props -> syms) {
      if(!props.imp)
        continue;

      var attrs = "";
      if(std.string.starts_with(sym, 'IID_') || std.string.starts_with(sym, 'LIBID_'))
        attrs = " DATA PRIVATE";
      else
        for(each priv -> PRIVATE_FUNCTIONS)
          if((sym == priv)
             || ((arch == 'x86') && std.string.starts_with(sym, priv + '@')))
            attrs = " PRIVATE";

      if((attrs == "") && !props.thunk)
        attrs = " DATA";

      sorted_syms[$] = sym + attrs;
    }

    sorted_syms = std.array.sort(sorted_syms,
        func(x, y) = std.string.to_lower(x) <=> std.string.to_lower(y));

    // compose DEF data.
    var def_data = "";
    for(each line -> DEF_COPYRIGHT)
      if(line == "")
        def_data += ";\n";
      else {
        def_data += "; ";
        def_data += line;
        def_data += "\n";
      }

    def_data += "\n";

    def_data += "LIBRARY \"";
    def_data += dll;
    def_data += "\"\n";

    def_data += "EXPORTS\n";
    for(each sym -> sorted_syms)  {
      def_data += "  ";
      def_data += sym;
      def_data += "\n";
    }

    // guess name of DEF file.
    var ext = std.string.pcre_find(dll, '\.[a-z0-9]{1,3}$');
    var def = std.string.replace_slice(dll, ext[0] ?? #dll, '.def');

    std.io.putfln("Writing: $1", arch / def);
    std.filesystem.write(arch / def, def_data);
  }
}
